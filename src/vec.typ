
/// Transforms two vectors $a, b$ of the same length with a function that 
/// receives pairs $(a_i,b_i)$ for all $i$. 
#let transform(
  /// First vector. 
  /// -> array
  a, 
  /// Second vector. 
  /// -> array
  b, 
  /// The function to apply to each item.
  /// -> function
  mapper
) = array.zip(a, b, exact: true).map(mapper)


/// Pair-wise adds the elements of two vectors of the same length. 
#let add(
  /// First vector. 
  /// -> array
  a, 
  /// Second vector.
  /// -> array
  b
) = transform(a, b, ((x,y)) => x + y)


/// Pair-wise subtracts the elements of two vectors of the same length. 
#let subtract(
  /// First vector. 
  /// -> array
  a, 
  /// Second vector.
  /// -> array
  b
) = transform(a, b, ((x,y)) => x - y)


/// Multiplies all entries of a vector with a scalar. 
#let multiply(
  /// Vector.
  /// -> array
  a, 
  /// Scalar. 
  /// -> int | float
  c
) = a.map(x => x * c)


/// Computes the inner product of two vectors. 
#let inner(
  /// First vector. 
  /// -> array
  a, 
  /// Second vector.
  /// -> array
  b
) = transform(a, b, ((x,y)) => x * y).sum()




#assert.eq(add((1,2,3), (4,5,6)), (5,7,9))
#assert.eq(subtract((1,2,3), (4,5,6)), (-3,-3,-3))
#assert.eq(multiply((1,2,3), 2), (2,4,6))
#assert.eq(inner((1,2,3), (4,5,6)), 32)




/// Adds random offsets to an array of values. Note that the seed needs to 
/// be changed manually. 
#let jitter(

  /// The values to transform. 
  /// -> array
  values, 

  /// The seed value for generating randomness. If set to `auto`, the seed will
  /// be generated by hashing the input data (note that two identical arrays
  /// will consequently be offset in the same way if the seed is `auto`). 
  /// -> auto | int
  seed: auto,

  /// The amount of jittering to apply. If @vec.jitter.distribution is
  /// `"uniform"`, this measures the bounds for the random offsets; if it is 
  /// set to `normal`, it specifies the standard deviation. 
  /// -> float
  amount: 0.1, 

  /// Which kind of distribution to use. 
  /// -> "uniform" | "normal"
  distribution: "uniform"

) = {
  import "@preview/suiji:0.4.0"

  if seed == auto {
    seed = values
      .enumerate()
      .map(((index, value)) => array((value).to-bytes()).sum()  * index)
      .sum()
  }

  let rng = suiji.gen-rng-f(seed)

  if distribution == "uniform" {
    add(
      values, 
      suiji.uniform-f(rng, low: -amount, high: amount, size: values.len()).at(1)
    )
  } else if distribution == "normal" {
    add(values, suiji.normal-f(rng, scale: amount, size: values.len()).at(1))
  } else {
    assert(
      false, 
      message: "Unknown distribution \"" + distribution + "\", expected \"uniform\" or \"normal\""
    )
  }
}

// Auto-seed, test for permutations
#assert.ne(
  jitter((0,1,2,4,3,5,6), seed: auto),
  jitter((0,1,2,3,4,5,6), seed: auto)
)

#assert.ne(
  jitter((0, 1, 2)), 
  (0, 1, 2)
)

#let k = jitter(range(101), seed: auto)
#k.len()

#jitter((1,2,3))